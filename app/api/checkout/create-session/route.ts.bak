import { NextResponse } from "next/server";
import Stripe from "stripe";
import { createClient } from "@supabase/supabase-js";

export const runtime = "nodejs";

function must(name: string) {
  const v = process.env[name];
  if (!v) throw new Error(`Missing env var: ${name}`);
  return v;
}

type IncomingItem = {
  name: string;
  qty: number;
  unit_cents: number;
};

type IncomingTotals = {
  subtotal_cents: number;
  tax_cents: number;
  total_cents: number;
};

const stripe = new Stripe(must("STRIPE_SECRET_KEY"), {
  apiVersion: "2023-10-16",
});

export async function POST(req: Request) {
  console.log("üî•üî• create-session HIT (FINGERPRINT-123) üî•üî•");

  try {
    const body = await req.json().catch(() => null);

    const items: IncomingItem[] | undefined = body?.items;
    const totals: IncomingTotals | undefined = body?.totals;

    if (!items || !Array.isArray(items) || items.length === 0) {
      return NextResponse.json({ error: "Missing items" }, { status: 400 });
    }
    if (
      !totals ||
      typeof totals.subtotal_cents !== "number" ||
      typeof totals.tax_cents !== "number" ||
      typeof totals.total_cents !== "number"
    ) {
      return NextResponse.json({ error: "Missing totals" }, { status: 400 });
    }

    // Validate items
    for (const it of items) {
      if (!it?.name || typeof it.name !== "string") {
        return NextResponse.json(
          { error: "Item missing name" },
          { status: 400 }
        );
      }
      if (!Number.isFinite(Number(it.qty)) || Number(it.qty) <= 0) {
        return NextResponse.json({ error: "Invalid qty" }, { status: 400 });
      }
      if (!Number.isFinite(Number(it.unit_cents)) || Number(it.unit_cents) < 0) {
        return NextResponse.json(
          { error: "Invalid unit_cents" },
          { status: 400 }
        );
      }
    }

    const totalCents = Number(totals.total_cents);
    if (!Number.isFinite(totalCents) || totalCents <= 0) {
      return NextResponse.json(
        { error: "Invalid total_cents" },
        { status: 400 }
      );
    }

    // ‚úÖ IMPORTANT FIX: use the CURRENT origin (3000 or 3001 automatically)
    const baseUrl = new URL(req.url).origin;

    // Supabase admin (service role)
    const supabase = createClient(
      must("NEXT_PUBLIC_SUPABASE_URL"),
      must("SUPABASE_SERVICE_ROLE_KEY"),
      { auth: { persistSession: false } }
    );

    // 1) Insert order
    const orderInsert: any = {
      order_number: Date.now(),
      source: "online",
      order_type: "takeout",
      status: "draft",
      payment_status: "unpaid",
      subtotal_cents: totals.subtotal_cents,
      tax_cents: totals.tax_cents,
      total_cents: totals.total_cents,
      payment_amount_cents: totals.total_cents,
      items_json: items, // snapshot for debugging (not used by KDS)
    };

    console.log("üßæ ORDER INSERT:", orderInsert);

    const { data: orderRow, error: orderErr } = await supabase
      .from("orders")
      .insert(orderInsert)
      .select("id, order_number")
      .single();

    if (orderErr || !orderRow?.id) {
      console.error("‚ùå ORDER INSERT FAILED:", orderErr);
      return NextResponse.json(
        { error: "Failed to create order", details: orderErr },
        { status: 500 }
      );
    }

    const orderId = String(orderRow.id);

    // 2) Insert order_items (THIS is what Success/KDS/Webhook depend on)
    const orderItemsToInsert = items.map((it) => ({
      order_id: orderId,
      menu_item_id: null,
      menu_item_name: it.name,
      qty: Number(it.qty),
      base_price_cents: Number(it.unit_cents),
      line_subtotal_cents: Number(it.unit_cents) * Number(it.qty),
      special_instructions: null,
    }));

    console.log("üßæ INSERTING ORDER ITEMS:", orderItemsToInsert);

    const { error: oiErr } = await supabase
      .from("order_items")
      .insert(orderItemsToInsert);

    if (oiErr) {
      console.error("‚ùå ORDER_ITEMS INSERT FAILED:", oiErr);

      // Roll back order so we don‚Äôt leave an orphan order with no items
      const { error: delErr } = await supabase
        .from("orders")
        .delete()
        .eq("id", orderId);
      if (delErr) console.error("‚ö†Ô∏è Failed to rollback order:", delErr);

      return NextResponse.json(
        { error: "Failed to create order items", details: oiErr },
        { status: 500 }
      );
    }

    // Optional verify
    const { data: verifyItems, error: vErr } = await supabase
      .from("order_items")
      .select("id")
      .eq("order_id", orderId);

    if (vErr) console.error("‚ö†Ô∏è ORDER_ITEMS VERIFY FAILED:", vErr);
    else console.log("‚úÖ ORDER_ITEMS VERIFIED COUNT:", verifyItems?.length ?? 0);

    // 3) Stripe session (SHOW REAL ITEMS IN STRIPE)
    const stripeLineItems: Stripe.Checkout.SessionCreateParams.LineItem[] =
      items.map((it) => ({
        quantity: Number(it.qty),
        price_data: {
          currency: "usd",
          unit_amount: Number(it.unit_cents),
          product_data: { name: String(it.name) },
        },
      }));

    // ‚úÖ Add tax as a line item so Stripe displays it
    if (Number(totals.tax_cents) > 0) {
      stripeLineItems.push({
        quantity: 1,
        price_data: {
          currency: "usd",
          unit_amount: Number(totals.tax_cents),
          product_data: { name: "Sales Tax (10.75%)" },
        },
      });
    }

    const origin =
      req.headers.get("origin") ||
      process.env.NEXT_PUBLIC_SITE_URL ||
      "http://localhost:3000";

    const session = await stripe.checkout.sessions.create({
      mode: "payment",
      payment_method_types: ["card"],
      line_items: stripeLineItems,
        success_url: `${origin}/success?orderId=${orderId}&session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${origin}/cancel?orderId=${orderId}`,
      metadata: { orderId },
    });

    console.log("‚úÖ STRIPE SESSION CREATED:", {
      id: session.id,
      url: session.url,
    });

    // 4) Save stripe session id
    const { error: updErr } = await supabase
      .from("orders")
      .update({
        stripe_checkout_session_id: session.id,
        stripe_session_id: session.id,
      })
      .eq("id", orderId);

    if (updErr) console.error("‚ö†Ô∏è ORDER UPDATE FAILED:", updErr);

    return NextResponse.json({ url: session.url, orderId, sessionId: session.id });
  } catch (err: any) {
    console.error("‚ùå CREATE SESSION ERROR:", err);
    return NextResponse.json(
      { error: err?.message ?? "Unknown error", details: String(err) },
      { status: 500 }
    );
  }
}